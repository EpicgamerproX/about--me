<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ice & Ember: Stable Fluids</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700&family=Montserrat:wght@300;600&display=swap');
        
        :root { --accent: #ffae00; --bg: #050505; }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            background-color: var(--bg); 
            color: white; 
            font-family: 'Montserrat', sans-serif; 
            overflow: hidden; 
            height: 100vh; width: 100vw;
        }

        /* --- UI --- */
        nav {
            position: fixed; top: 40px; left: 50%; transform: translateX(-50%);
            z-index: 100; display: flex; gap: 20px;
            background: rgba(10,10,10,0.8); padding: 12px 30px; border-radius: 100px;
            border: 1px solid rgba(255,255,255,0.15); backdrop-filter: blur(20px);
        }
        .nav-btn {
            background: transparent; border: none; color: rgba(255,255,255,0.5);
            font-size: 1rem; font-weight: 600; cursor: pointer; transition: 0.3s;
            text-transform: uppercase; letter-spacing: 1px;
        }
        .nav-btn.active { color: white; text-shadow: 0 0 10px rgba(255,255,255,0.5); }

        .section {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            opacity: 0; pointer-events: none; transition: opacity 1s ease;
        }
        .section.active { opacity: 1; pointer-events: all; }

        #portfolio-section { display: flex; justify-content: center; align-items: center; perspective: 1000px; }
        .ice-slab {
            width: 70vw; height: 60vh;
            background: linear-gradient(135deg, rgba(255,255,255,0.05), rgba(255,255,255,0.01));
            border: 1px solid rgba(255,255,255,0.1); border-radius: 12px;
            transform: rotateX(20deg); box-shadow: 0 50px 100px black;
            display: flex; justify-content: center; align-items: center;
            position: relative;
        }
        .ice-text { text-align: center; }
        h1 { font-family: 'Playfair Display'; font-size: 4rem; margin-bottom: 10px; }
        
        #webgl-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        
        .ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; justify-content: space-between; align-items: center;
            padding: 0 10%; pointer-events: none;
        }
        .card {
            width: 280px; padding: 40px 30px;
            background: rgba(5,5,5,0.85); border-left: 4px solid var(--accent);
            backdrop-filter: blur(10px); color: #ddd;
            opacity: 0; transform: translateY(50px); transition: 0.8s cubic-bezier(0.2, 0.8, 0.2, 1);
        }
        .section.active .card { opacity: 1; transform: translateY(0); }
        .card h3 { color: var(--accent); font-family: 'Playfair Display'; margin-bottom: 10px; font-size: 1.5rem; }
        .card p { font-size: 0.85rem; line-height: 1.6; color: #aaa; }

    </style>
</head>
<body>

    <nav>
        <button class="nav-btn active" onclick="setTab('portfolio')">Portfolio</button>
        <button class="nav-btn" onclick="setTab('projects')">Projects</button>
    </nav>

    <section id="portfolio-section" class="section active">
        <div class="ice-slab">
            <canvas id="frost-canvas" style="position: absolute; top:0; left:0; width:100%; height:100%; opacity: 0.4; mix-blend-mode: overlay;"></canvas>
            <div class="ice-text">
                <h1>THE FROST</h1>
                <p style="letter-spacing: 5px; opacity: 0.7;">DIGITAL DESIGN</p>
            </div>
        </div>
    </section>

    <section id="projects-section" class="section">
        <canvas id="webgl-canvas"></canvas>
        <div class="ui-layer">
            <div class="card" id="card-left">
                <h3>STABLE FLUIDS</h3>
                <p>Navier-Stokes solver running in real-time. This isn't an animation, it's a physics simulation.</p>
            </div>
            <div class="card" id="card-right">
                <h3>TURBULENCE</h3>
                <p>Mouse movement injects velocity vectors into the grid, creating advection and diffusion.</p>
            </div>
        </div>
    </section>

    <script type="module">
        import * as THREE from 'three';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

        let currentTab = 'portfolio';
        let mouse = { x: 0, y: 0 };
        const windowHalfX = window.innerWidth / 2;
        const windowHalfY = window.innerHeight / 2;

        // --- 1. FROST CANVAS ---
        const fC = document.getElementById('frost-canvas');
        const fX = fC.getContext('2d');
        let trails = [];
        const resizeFrost = () => { fC.width = fC.offsetWidth; fC.height = fC.offsetHeight; };
        window.addEventListener('resize', resizeFrost); resizeFrost();

        document.addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX - windowHalfX) / windowHalfX;
            mouse.y = (e.clientY - windowHalfY) / windowHalfY;
            if(currentTab === 'portfolio') {
                const r = fC.getBoundingClientRect();
                trails.push({ x: e.clientX - r.left, y: e.clientY - r.top, a: 0.5 });
            }
        });

        function renderIce() {
            fX.clearRect(0,0, fC.width, fC.height);
            trails.forEach(t => {
                t.a -= 0.01; fX.beginPath(); fX.arc(t.x, t.y, 30, 0, 7);
                fX.fillStyle = `rgba(255,255,255,${t.a})`; fX.fill();
            });
            trails = trails.filter(t => t.a > 0);
            requestAnimationFrame(renderIce);
        }
        renderIce();


        // ==========================================
        // === JOS STAM STABLE FLUIDS SOLVER (JS) ===
        // ==========================================
        const N = 64; // Grid Resolution
        const iter = 4; // Solver Iterations
        const size = (N + 2) * (N + 2);
        
        let u = new Float32Array(size); // Velocity X
        let v = new Float32Array(size); // Velocity Y
        let u_prev = new Float32Array(size);
        let v_prev = new Float32Array(size);
        let dens = new Float32Array(size); // Density (The Whiskey color)
        let dens_prev = new Float32Array(size);

        function IX(x, y) { return x + (N + 2) * y; }

        function add_source(x, s, dt) {
            for (let i = 0; i < size; i++) x[i] += dt * s[i];
        }

        function set_bnd(b, x) {
            for (let i = 1; i <= N; i++) {
                x[IX(0, i)] = b === 1 ? -x[IX(1, i)] : x[IX(1, i)];
                x[IX(N + 1, i)] = b === 1 ? -x[IX(N, i)] : x[IX(N, i)];
                x[IX(i, 0)] = b === 2 ? -x[IX(i, 1)] : x[IX(i, 1)];
                x[IX(i, N + 1)] = b === 2 ? -x[IX(i, N)] : x[IX(i, N)];
            }
            x[IX(0, 0)] = 0.5 * (x[IX(1, 0)] + x[IX(0, 1)]);
            x[IX(0, N + 1)] = 0.5 * (x[IX(1, N + 1)] + x[IX(0, N)]);
            x[IX(N + 1, 0)] = 0.5 * (x[IX(N, 0)] + x[IX(N + 1, 1)]);
            x[IX(N + 1, N + 1)] = 0.5 * (x[IX(N, N + 1)] + x[IX(N + 1, N)]);
        }

        function lin_solve(b, x, x0, a, c) {
            for (let k = 0; k < iter; k++) {
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        x[IX(i, j)] = (x0[IX(i, j)] + a * (x[IX(i - 1, j)] + x[IX(i + 1, j)] + x[IX(i, j - 1)] + x[IX(i, j + 1)])) / c;
                    }
                }
                set_bnd(b, x);
            }
        }

        function diffuse(b, x, x0, diff, dt) {
            let a = dt * diff * N * N;
            lin_solve(b, x, x0, a, 1 + 4 * a);
        }

        function advect(b, d, d0, u, v, dt) {
            let i0, j0, i1, j1;
            let x, y, s0, t0, s1, t1, dt0;
            dt0 = dt * N;
            for (let j = 1; j <= N; j++) {
                for (let i = 1; i <= N; i++) {
                    x = i - dt0 * u[IX(i, j)];
                    y = j - dt0 * v[IX(i, j)];
                    if (x < 0.5) x = 0.5; if (x > N + 0.5) x = N + 0.5;
                    i0 = Math.floor(x); i1 = i0 + 1;
                    if (y < 0.5) y = 0.5; if (y > N + 0.5) y = N + 0.5;
                    j0 = Math.floor(y); j1 = j0 + 1;
                    s1 = x - i0; s0 = 1 - s1;
                    t1 = y - j0; t0 = 1 - t1;
                    d[IX(i, j)] = s0 * (t0 * d0[IX(i0, j0)] + t1 * d0[IX(i0, j1)]) +
                                  s1 * (t0 * d0[IX(i1, j0)] + t1 * d0[IX(i1, j1)]);
                }
            }
            set_bnd(b, d);
        }

        function project(u, v, p, div) {
            for (let j = 1; j <= N; j++) {
                for (let i = 1; i <= N; i++) {
                    div[IX(i, j)] = -0.5 * (u[IX(i + 1, j)] - u[IX(i - 1, j)] + v[IX(i, j + 1)] - v[IX(i, j - 1)]) / N;
                    p[IX(i, j)] = 0;
                }
            }
            set_bnd(0, div);
            set_bnd(0, p);
            lin_solve(0, p, div, 1, 4);
            for (let j = 1; j <= N; j++) {
                for (let i = 1; i <= N; i++) {
                    u[IX(i, j)] -= 0.5 * N * (p[IX(i + 1, j)] - p[IX(i - 1, j)]);
                    v[IX(i, j)] -= 0.5 * N * (p[IX(i, j + 1)] - p[IX(i, j - 1)]);
                }
            }
            set_bnd(1, u);
            set_bnd(2, v);
        }

        function fluidStep() {
            let dt = 0.2;
            let diff = 0.0001;
            let visc = 0.0001;
            
            // Add Forces (Mouse Interaction handled separately)
            
            // Velocity Step
            diffuse(1, u_prev, u, visc, dt);
            diffuse(2, v_prev, v, visc, dt);
            project(u_prev, v_prev, u, v);
            advect(1, u, u_prev, u_prev, v_prev, dt);
            advect(2, v, v_prev, u_prev, v_prev, dt);
            project(u, v, u_prev, v_prev);
            
            // Density Step
            diffuse(0, dens_prev, dens, diff, dt);
            advect(0, dens, dens_prev, u, v, dt);
        }

        // ==========================================
        // === 3D ENGINE INTEGRATION ===
        // ==========================================
        const canvas = document.querySelector('#webgl-canvas');
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.8;

        const scene = new THREE.Scene();

        new RGBELoader()
            .setPath('https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/')
            .load('studio_small_09_1k.hdr', function (texture) {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                scene.environment = texture;
            });

        const camera = new THREE.PerspectiveCamera(40, window.innerWidth/window.innerHeight, 0.1, 100);
        camera.position.set(0, 4, 14);

        const glassGroup = new THREE.Group();
        glassGroup.position.y = -2.5; 
        scene.add(glassGroup);

        // --- MATERIALS ---
        const glassMat = new THREE.MeshPhysicalMaterial({
            color: 0xffffff, transmission: 1.0, thickness: 0.1, roughness: 0,
            ior: 1.5, clearcoat: 1.0, transparent: true, side: THREE.FrontSide 
        });

        // FLUID TEXTURE (Canvas to Texture)
        const fluidCanvas = document.createElement('canvas');
        fluidCanvas.width = N;
        fluidCanvas.height = N;
        const fluidCtx = fluidCanvas.getContext('2d');
        const fluidTexture = new THREE.CanvasTexture(fluidCanvas);
        
        // Material that uses the fluid texture
        const fluidPlaneMat = new THREE.MeshBasicMaterial({
            map: fluidTexture,
            transparent: true,
            opacity: 0.9,
            color: 0xffaa00, // Whiskey Tint
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending
        });

        // --- GEOMETRY ---
        // 1. The Glass
        const cupProfile = [
            new THREE.Vector2(0, 0), new THREE.Vector2(3, 0),    
            new THREE.Vector2(3.2, 5), new THREE.Vector2(3.0, 5),  
            new THREE.Vector2(2.8, 0.5), new THREE.Vector2(0, 0.5)   
        ];
        const cup = new THREE.Mesh(new THREE.LatheGeometry(cupProfile, 64), glassMat);
        cup.renderOrder = 2;
        glassGroup.add(cup);

        // 2. The Fluid Plane (Crucial for visualizing the sim)
        // We place this INSIDE the glass to show the currents
        const planeGeo = new THREE.PlaneGeometry(5, 5);
        const fluidPlane = new THREE.Mesh(planeGeo, fluidPlaneMat);
        fluidPlane.position.y = 2.5;
        fluidPlane.renderOrder = 1;
        // Make it billboard towards camera roughly, but spin with glass
        glassGroup.add(fluidPlane);

        // 3. Ice
        const iceCube = new THREE.Mesh(
            new THREE.BoxGeometry(1.6, 1.6, 1.6),
            new THREE.MeshPhysicalMaterial({transmission: 0.9, roughness: 0.2, ior: 1.31, thickness: 1.5, color: 0xffffff})
        );
        iceCube.position.set(0, 1.5, 0);
        iceCube.rotation.set(0.5, 0.5, 0);
        glassGroup.add(iceCube);

        // LIGHTING
        const backLight = new THREE.PointLight(0xffffff, 80);
        backLight.position.set(0, 5, -10);
        scene.add(backLight);
        const fillLight = new THREE.DirectionalLight(0xffaa00, 3);
        fillLight.position.set(-5, 5, 5);
        scene.add(fillLight);

        // --- SIMULATION LOOP ---
        const cL = document.getElementById('card-left');
        const cR = document.getElementById('card-right');
        
        // Pre-fill density so it's not empty
        for(let i=0; i<size; i++) dens[i] = 0.5;

        function drawFluid() {
            const id = fluidCtx.createImageData(N, N);
            const d = id.data;
            for (let i = 0; i < N; i++) {
                for (let j = 0; j < N; j++) {
                    const idx = IX(i+1, j+1); // +1 because grid has boundaries
                    const density = dens[idx]; 
                    // Render density as alpha/brightness
                    const px = (i + j * N) * 4;
                    // Invert look: High density = bright amber
                    let val = Math.min(255, density * 255);
                    d[px] = 255; // R
                    d[px+1] = 200; // G
                    d[px+2] = 100; // B
                    d[px+3] = val; // Alpha
                }
            }
            fluidCtx.putImageData(id, 0, 0);
            fluidTexture.needsUpdate = true;
        }

        // Handle Mouse Interaction with Fluid
        let lastMouseX = 0, lastMouseY = 0;
        function interactFluid() {
            // Map mouse to grid
            let mx = Math.floor(((mouse.x + 1) / 2) * N);
            let my = Math.floor((1 - (mouse.y + 1) / 2) * N); // Invert Y
            
            // Bounds check
            if (mx < 1 || mx > N || my < 1 || my > N) return;

            // Inject velocity based on movement
            let dx = mouse.x - lastMouseX;
            let dy = mouse.y - lastMouseY;
            
            let idx = IX(mx, my);
            u[idx] += dx * 500; // Force multiplier
            v[idx] += dy * 500;
            dens[idx] += 5; // Add "dye" (density) on touch

            lastMouseX = mouse.x;
            lastMouseY = mouse.y;
        }

        function animate() {
            requestAnimationFrame(animate);

            if(currentTab === 'projects') {
                // 1. Run Physics
                interactFluid();
                fluidStep(); // Advect, Diffuse, Project
                drawFluid(); // Update texture

                // 2. Rotate Glass
                glassGroup.rotation.y += (mouse.x * 0.5 - glassGroup.rotation.y) * 0.05;
                glassGroup.rotation.x += (mouse.y * 0.2 - glassGroup.rotation.x) * 0.05;

                // 3. Ice Float
                iceCube.rotation.y += 0.01;
                iceCube.position.y = 1.5 + Math.sin(Date.now()*0.001) * 0.1;

                // UI
                cL.style.transform = `translate(${mouse.x * -40}px, ${mouse.y * -20}px)`;
                cR.style.transform = `translate(${mouse.x * -60}px, ${mouse.y * -30}px)`;

                renderer.render(scene, camera);
            }
        }
        animate();

        window.setTab = (t) => {
            currentTab = t;
            document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
            document.getElementById(t + '-section').classList.add('active');
            document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
        };

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
